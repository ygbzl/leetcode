void insert(String key, String value);
String search(String key);
String delete(String key);


If a Graph has V vertices and E edges. What is the time complexity of BFS in terms of V, E
O(V+E)

AABBCC -> BBCCAA
[]

AABBCC -> AABBCB -> AABBBB
[AABBCB, AABBCC,AABBBB]

AABBCC
3*k
.size()
n

AABBCC : What is the total number of combinations that you can generate by interchanging a letter. That will give you number of nodes(V) in the graph

V: 3^k
0(3^k);

int minTransformations(String startWord, String endWord, HashSet<String> validTransformationStrings) {
    if (validTransformationString == null){
        return -1;
    }
    
    if (startWord.equals(endWord)){
        return 0;
    }
    
    validTransformationString.add(startWord);
    validTransformationString.add(endWord);
    
    Queue<String> queue = new LinkedList<String>();
    HashSet<String> hash = new HashSet<String>();
    
    queue.offer(startWord);
    hash.add(startWord);
    
    
    int pathLen = 0;
    whiel (!q.isEmpty()){
        pathLen++;
        int size = queue.size();
      //  for (int i = 0; i < size; i++){
            String word = queue.poll();
            // O(k)
            for (String nextWord : getNext(word, validTransformationString)){
                if (hash.contains(nextWord)){
                    continue;
                }
                if (nextWord.equals(end)){
                    return pathLen;
                }
                hash.add(nextWord);
                queue.offer(nextWord);
            }
      //  }
    }
    
    return -1;
}


private String replace(String startWord, int index, char c){
    // word.length() == k
    // O(k)
    char[] chars = s.toCharArray();
    chars[index] = c;
    return new String(chars);
}

private ArrayList<String> getNext(String word, HashSet<String> validTransformationString){
    //O(k)
    ArrayList<String> nextWords = new ArrayList<String>();
    // O(1)*3 = O(1)
    for (char c = 'A'; c <= 'C'; c++){
        // O(k)
        for (int i = 0; i < word.length(); i++){
            if (c == word.charAt(i)){
                continue;
            }
            String next = replace(word, i, c);
            if(validTransformationString.contains(next)){
                nextWords.add(next);
            }
        }
    }
    
    return nextWords;
}



hashtable, BST, unordered map, balanced BST

LC 17 原題

project: When you did not have enough information when you get the requirement, how did you solve that?

dict:  int parseTo real english word, which data structure?    hastset trie  time Complexity?

3 sum,   follow up: with hashmap?

LC 155  O(1)space

validate binary search tree

//challenging project

Sysmetric Tree

implement a queue using an array   dequeue, enqueue

tree zigzag traversal


报一个刚刚的面经：Write a function that takes as input an array of objects/strings.  The objects will be either integers or character representations of +, -, and * (let's ignore division at the moment).  It should return the result by applying the arithmetical operations defined in the Reverse Polish Notation of the array (also known as postfix notation).

# Examples:
# Postfix             Infix     Solution
# [1, 3, +] =>        1 + 3  =>  4
# [6, 3, -] =>        6 - 3 => 3
# [2, 3, +, 5, *]  => (2 + 3) * 5 => 5 * 5 => 25
# [2, 3, 5, *, +]  => 2 + (3 * 5) => 2 + 15 => 17

# Corner cases
# [1,2,1,+]
# [1,2,+,+]
# [1,2,!]



2点面经：
口音听不太听出来哪国面试官，带点口音，人很nice
* 介绍一个在project中别人没想到而你想到的能改进项目的点子
* 写代码：打印一个带规律的matrix，1,2,3; 2,4,6; 3,6,9;  
* 两个全是integer没有sort带重复数字的文件，用linux命令找出两个文件中重复的数字（写代码）
    * follow up1: 用O(n)复杂度(可不用linux)？（说想法）
    * follow up2: 如果两个文件太大一次不能读入内存怎么办？(说想法)
* （写代码）OOD，设计一个Zoo，里面有各种动物，考虑笼子类型，食物类型，饲养员，中间穿插问LinkedList和ArrayList的区别。
* （写代码）判断integer某个bit是不是1.
* 问问题。


lc 373
lc 88  follow up: k arrays




